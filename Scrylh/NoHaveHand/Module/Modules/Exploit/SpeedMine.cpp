#include "SpeedMine.h"
#include "../../../../SDK/CAttribute.h"
#include "../pch.h"

using namespace std;
SpeedMine::SpeedMine() : IModule(0, Category::COMBAT, "Regenerates your health") {
	registerEnumSetting("Mode", &mode, 0);
	mode.addEntry("Hive", 0);
	
	registerFloatSetting("Range", &range, range, 1, 10);
	registerIntSetting("ContinueDelay", &delay, delay, 0, 20);
	registerIntSetting("MineDelay", &minedelay, minedelay, 0, 30);
	registerBoolSetting("Visual", &visual, visual);
	registerBoolSetting("HealthVisual", &healthvisual, healthvisual);
}

const char* SpeedMine::getRawModuleName() {
	return "SpeedMine";
}

const char* SpeedMine::getModuleName() {
	if (mode.getSelectedValue() == 0) name = string("SpeedMine ") + string(GRAY) + string("Hive");
	if (mode.getSelectedValue() == 1) name = string("SpeedMine ") + string(GRAY) + string("HiveTest");
	return name.c_str();
}

bool SpeedMine::selectPickaxe() {
	C_PlayerInventoryProxy* supplies = g_Data.getLocalPlayer()->getSupplies();
	C_Inventory* inv = supplies->inventory;
	auto prevSlot = supplies->selectedHotbarSlot;

	for (int n = 0; n < 36; n++) {
		C_ItemStack* stack = inv->getItemStack(n);
		if (stack->item != nullptr) {
			if (stack->getItem()->isPickaxe()) {
				if (prevSlot != n) {
					supplies->selectedHotbarSlot = n;
				}
				return true;
			}
		}
	}
	return false;
}
/*float SpeedMine::getDestroySpeed(int slot, C_Block& block, float destroySpeedDivisor = 1.0f) {

	auto player = g_Data.getLocalPlayer();

	if (!player) return -1;
	C_PlayerInventoryProxy* supplies = g_Data.getLocalPlayer()->getSupplies();
	C_Inventory* inv = supplies->inventory;
	bool onGround = player->onGround();
	player->onGround(true);
	int currentSlot = supplies->selectedHotbarSlot;
	supplies->selectedHotbarSlot = slot;
	C_ItemStack* stack = inv->getItemStack(slot);
	C_ItemStack item = *inv->getItemStack(slot);
	float destroySpeed = (*stack->item)->getDestroySpeed(item,block) / destroySpeedDivisor;
	supplies->selectedHotbarSlot = currentSlot;
	player->onGround(onGround);

	return destroySpeed;
}*/
void SpeedMine::onEnable() {
	auto player = g_Data.getLocalPlayer();
	if (player == nullptr) return;
	rot = false;
	bypassrot = false;
	firstbreak = false;
	continuemine = false;
	canattack = true;
	isregen = true;
	enabledticks = 0;
	blocksBroke = 0;

	animYawB = player->yawUnused1;
	animPitchB = player->pitch;

	C_PlayerInventoryProxy* supplies = g_Data.getLocalPlayer()->getSupplies();
	slot = supplies->selectedHotbarSlot;
}
bool hasClicked = false;

void SpeedMine::onTick(C_GameMode* gm) {
	auto player = g_Data.getLocalPlayer();
	if (player == nullptr || moduleMgr->getModule<Scaffold>()->isEnabled()) return;

	tick++;
	enabledticks++;
	C_PlayerInventoryProxy* supplies = g_Data.getLocalPlayer()->getSupplies();

	if (g_Data.canUseMoveKeys() && g_Data.isRightClickDown() && !hasClicked) {
		hasClicked = true;

		switch (mode.getSelectedValue()) {
		case 0: // Hive
		{
			PointingStruct* pointing = g_Data.getLocalPlayer()->pointingStruct;
			blockPos = pointing->block;
			vec3_t blockPos2 = pointing->block.toVector3();
			destroy = false;
			vec2_t angel = player->getPos()->CalcAngle(vec3_t(blockPos.x, blockPos.y, blockPos.z));
			bool isDestroyed2 = false;
			vec3_ti AirCheckPos;

			if (continuemine) {
				destroy = true;
				tempblockPos = blockPos2;
			}
			else {
				destroy = true;
				gm->startDestroyBlock(blockPos, 1, isDestroyed2);
				continuemine = true;
				tempblockPos = blockPos2;
			}

			int aids = delay - 1;
			if (destroy) {
				if (swing) player->swing();
				slot = supplies->selectedHotbarSlot;

				static bool restored = false;
				if (!selectPickaxe()) {
					if (!restored) restored = true;
					else {
						setEnabled(false);
					}
					return;
				}

				restored = false;
				if (enabledticks > minedelay && g_Data.canUseMoveKeys()) {
					player->bodyYaw = angel.y;
					player->yawUnused1 = angel.y;
					player->pitch = angel.x;
				}

				if (enabledticks > minedelay - 1) {
					breaknow = true;
				}
				else {
					breaknow = false;
				}

				if (firstbreak && enabledticks > minedelay) {
					gm->destroyBlock(&blockPos, 0);
					hasDestroyed = true;
					rot = false;
					enabledticks = 0;
					gm->stopDestroyBlock(blockPos);
					continuemine = false;
				}

				if (firstbreak) {
					firstbreak = false;
				}
				else {
					firstbreak = true;
				}

				supplies->selectedHotbarSlot = slot;
				if (!swing) player->swing();
				return;
			}

			if (hasDestroyed) {
				hasDestroyed = false;
				blocksBroke += 1;
			}

			if (blocksBroke > 4) blocksBroke = 0;
			clientMessageF("minedelay", minedelay);
		}
		}

		if (!destroy) {
			isregen = false;
			continuemine = false;
			canattack = true;
			enabledticks = 0;
			rot = false;
			breaknow = false;
		}
	}

	if (!g_Data.isRightClickDown()) hasClicked = false;
}

void SpeedMine::onPlayerTick(C_Player* plr) {
	auto player = g_Data.getLocalPlayer();
	if (player == nullptr) return;

	vec2_t angle = player->getPos()->CalcAngle(vec3_t(blockPos.x, blockPos.y, blockPos.z));
	if (animYaw > angle.y)
		animYaw -= ((animYaw - angle.y) / 10);
	else if (animYaw < angle.y)
		animYaw += ((angle.y - animYaw) / 10);
	if (destroy) {
		//g_Data.getClientInstance()->loopbackPacketSender->sendToServer(&at);
	}
}
void SpeedMine::onPreRender(C_MinecraftUIRenderContext* renderCtx) {
	auto player = g_Data.getLocalPlayer();
	if (player == nullptr) return;
	if (visual && destroy) {
		if (blockPos != vec3_ti(0, 0, 0)) {
			DrawUtils::setColor(.75f, .25f, .5f, 1.f);
			DrawUtils::drawBox(blockPos.toVector3().add(0.f, 0.f, 0.f),
				blockPos.add(1).toVector3().add(0.f, 0.f, 0.f), .3f);
		}
	}
}
void SpeedMine::onSendPacket(Packet* packet) {
	auto player = g_Data.getLocalPlayer();
	if (player == nullptr) return;

	if (packet->isInstanceOf<PlayerAuthInputPacket>() && breaknow) {
		auto* movePacket = reinterpret_cast<PlayerAuthInputPacket*>(packet);
		vec2_t angle = player->getPos()->CalcAngle(vec3_t(blockPos.x, blockPos.y, blockPos.z));
		if (animYaw > angle.y)
			animYaw -= ((animYaw - angle.y) / 10);
		else if (animYaw < angle.y)
			animYaw += ((angle.y - animYaw) / 10);
		if (destroy) {
			if (g_Data.canUseMoveKeys()) {
				movePacket->yaw = angle.y;
				movePacket->yawUnused = angle.y;
				movePacket->pitch = angle.x;
			}
		}
	}
}

void SpeedMine::onDisable() {
	auto player = g_Data.getLocalPlayer();
	if (player == nullptr) return;

	blocksBroke = 0;
	destroy = false;
	tick = 0;
	isregen = false;
	rot = false;
	bypassrot = false;
	canattack = true;
}
